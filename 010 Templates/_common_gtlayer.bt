//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: GTChunk/Zone Layer Parsing
//   Authors: freakbyte, FallenAvatar, Arkii, Xsear
//  Category: Firefall
// File Mask:
//  ID Bytes:
//------------------------------------------------

#include "_common_types.bt"

#ifndef FF_COMMON_GTLAYER
#define FF_COMMON_GTLAYER 1

local uint64 NODE_TAG_MAGIC<hidden=true> = 0x12ED5A12ED5B12ED;

typedef enum <uint32> {
    // Hack
    NO_PARENT = 0xFFFFFFFF,

    // Zone
    ZONE                                             = 0x30000,
    ZONE_SKYBOX                                      = 0x20000,
    ZONE_DEFAULT_ENVIRONMENT                         = 0x20100,
        DEFAULT_ENVIRONMENT_10000                    = 0x02710, // Two vec3s. For some (indoor?) zones, they are the same. Older versions (1710) have only one.
    ZONE_MELDING                                     = 0x20200,
        MELDING_PERIMITER                            = 5,
    ZONE_WATER                                       = 0x20300,
        WATER_CHILD                                  = 4,       // Legacy
    ZONE_CHUNK_INFO                                  = 0x20400, 
        CHUNK_INFO_RANGE                             = 0x10000,
        CHUNK_INFO_REF2                              = 0x10100,
        CHUNK_INFO_REF                               = 0x10101,
    ZONE_MELDING_HEIGHT_MAP_DATA                     = 0x20700,
    ZONE_PATH                                        = 0x20800,
    ZONE_WORLD_CHUNK_IMPORT                          = 0x20900,
    ZONE_135168                                      = 0x21000, // Bounds but for what, hey are bottom left and top right of zone though not all the way to the edge.
    ZONE_PROP_ENCOUNTER_NAME_REGISTRY                = 0x21200,
    ZONE_PROP                                        = 0x21400,
    ZONE_CAMERA_SEQUENCE                             = 0x21500,
    ZONE_TRANSFER_BOUNDS                             = 0x21600,
    ZONE_SUBZONE_REGION                              = 0x21700,

    // GTChunk Index
    CHUNK                                            = 0x40000,
    CHUNK_LOD                                        = 0x40001,
    CHUNK_SUBCHUNK                                   = 0x40002,
    
    // GTChunk Payload
    CHUNK_TERRAIN                                    = 0x40100, // parent, children are "terrain chunk layer"
        TERRAIN_T0                                   = 0, // meta, init?
        TERRAIN_MATERIALS                            = 1, // parent, children are "terrain chunk material layer"
            TERRAIN_MATERIAL                         = 5,
        TERRAIN_QUADTREE                             = 2, // has data and children, children are "terrain chunk quadtree layer"
            TERRAIN_QUADTREE_BLENDWEIGHT             = 8, // children are "terrain blend weight layer"
                TERRAIN_QUADTREE_BLENDWEIGHT_0       = 0,
                TERRAIN_QUADTREE_BLENDWEIGHT_2       = 2,
            TERRAIN_QUADTREE_T9                      = 9,
            TERRAIN_QUADTREE_T11                     = 11,
            TERRAIN_QUADTREE_QQ1                     = 0x55555555,
            TERRAIN_QUADTREE_QQ2                     = 0x575FFFF8,
            TERRAIN_QUADTREE_QQ3                     = 0xA0A0A0A0,
            TERRAIN_QUADTREE_QQ4                     = 0xAA2A2A0A,
            TERRAIN_QUADTREE_QQ5                     = 0xEFFFDFD7,
            TERRAIN_QUADTREE_QQ6                     = 0xF77F7F97,
        TERRAIN_T3                                   = 3, // list of terrain materials to load
        TERRAIN_T4                                   = 4, // shape data?
    CHUNK_COLLISION1                                 = 0x40101, // main collision data
    CHUNK_SUBZONEGRID                                = 0x40102,
    CHUNK_COLLISION3                                 = 0x40103, // blocking volumes?
    CHUNK_PROP_ENCOUNTER_NAME_REGISTRY2              = 0x40104,
    CHUNK_COLLISION2                                 = 0x40105, // water volumes?
    CHUNK_PROP                                       = 0x40200,
    CHUNK_GEOMETRY2                                  = 0x40203,
    CHUNK_PROP_ENCOUNTER_NAME_REGISTRY               = 0x40204,
    CHUNK_VEGETATION                                 = 0x40205,
    CHUNK_OVERLAY                                    = 0x40206,
    CHUNK_SECTORS                                    = 0x40207,
    CHUNK_WATER                                      = 0x40208,
    CHUNK_VEGETATION2                                = 0x40209,
    CHUNK_GEOMETRY                                   = 0x40210,
  
    PROP_DOODAD                                      = 0x50000,
    PROP_ENVIRONMENT                                 = 0x50001,
      ENVIRONMENT_0031                               = 0x0001F,
      ENVIRONMENT_0032                               = 0x00020,
      ENVIRONMENT_0033                               = 0x00021,
      ENVIRONMENT_0034                               = 0x00022,
      ENVIRONMENT_0202                               = 0x000CA,
      ENVIRONMENT_0203                               = 0x000CB,
      ENVIRONMENT_0302                               = 0x0012E,
      ENVIRONMENT_0303                               = 0x0012F,
      ENVIRONMENT_0304                               = 0x00130,
      ENVIRONMENT_0400                               = 0x00190,
      ENVIRONMENT_0401                               = 0x00191,
      ENVIRONMENT_0501                               = 0x001F5,
      ENVIRONMENT_0600                               = 0x00258,
      ENVIRONMENT_0601                               = 0x00259,
      ENVIRONMENT_0700                               = 0x002BC,
      ENVIRONMENT_0800                               = 0x00320,
      ENVIRONMENT_0900                               = 0x00384,
      ENVIRONMENT_1000                               = 0x003E8,
      ENVIRONMENT_1100                               = 0x0044C,
      ENVIRONMENT_1200                               = 0x004B0,
      ENVIRONMENT_1300                               = 0x00514,
      ENVIRONMENT_1400                               = 0x00578,
    PROP_PROBEDATA                                   = 0x50006,
    PROP_DECALINSTANCES1                             = 0x50008,
    PROP_PARTICLEDATA                                = 0x5000D,
    PROP_LIGHTDATA                                   = 0x50011,
    PROP_SECTOR                                      = 0x50013, // Child of CHUNK_SECTORS
    PROP_AUDIOVOLUME                                 = 0x50014,
    PROP_MONSTER                                     = 0x50017,
    PROP_DECALINSTANCES2                             = 0x50018,
} LayerType;

struct DataUnkBytes(int dataSize) {
    byte data[dataSize]<name="Bytes">;
};

// CHUNK
struct ChunkRootLayerData {
    uint version;
    uint64 timestamp;
    uint numLods;
};

// CHUNK_LOD
struct ChunkLodLayerData {
    uint lodIdx;
    uint numSubChunks <read=ReadNumSubChunks, comment="">;
    uint dataOffset<comment="Bytes after root node until we find this data">;
    uint compressedSize<comment="Size of the data including type and compression headers">; 
    uint uncompressedSize<comment="Size of the decompressed payload">;
};

string ReadNumSubChunks(uint numSubChunks)
{
    local uint numSubChunksCount = 1 << 2 * numSubChunks;
    local string count;
    SPrintf(count, "%i", numSubChunksCount);
    return count;
}

// CHUNK_SUBCHUNK
struct ChunkSubChunkLayerData {
    uint dataOffset<comment="Bytes after root node until we find this data">;
    uint compressedSize<comment="Size of the data including type and compression headers">; 
    uint uncompressedSize<comment="Size of the decompressed payload">;
    Vec3f boundsMin<read=Vec3fDisplay, comment="">;
    Vec3f boundsMax<read=Vec3fDisplay, comment="">;
};

// CHUNK_WATER
// ZONE_WATER
struct unk_WaterFlagData {
    float a;
    uint b;
};
struct WaterLayerData {    
    Vec3f position <comment="Origin">;
    
    uint unk2 <comment="0, 2 observed. doesn't seem to be a count.">; 
    uint always_1 <comment="No other values than 1 observed.">;
    uint flags <comment="Usage of first 3 bits observed, affects the amount of unk_flagdata present.">;
    
    if (flags & 0x01)
    {
        unk_WaterFlagData fd_1;
    }

    if (flags & 0x02)
    {
        unk_WaterFlagData fd_2[2];
    }    

    if (flags & 0x04)
    {
        // 0.25, 0.5, 0.75, 1
        unk_WaterFlagData fd_3[4];
    }

    Vec3f textureScale <comment="Texture scaling related">;
    
    uint waterdesc_sdb_id;    
    uint always_zero <comment="No other values than 0 observed.">;

    uint data1_count;
    Vec3f data1[data1_count] <read=Vec3fDisplay>;

    uint data2_count;
    Vec2f data2[data2_count] <read=Vec2fDisplay>;

    uint data3_count;
    uint data3[data3_count];

    uint data4_count;
    uint data4[data4_count];

    uint data5_count;
    uint data5[data5_count] <comment="Some indexing or mapping data">;

    byte moreData <comment="Seems to be a bool">;
    if (moreData > 0x00) {
        int count6 <comment="Some x?">; 
        uint count7 <comment="Some y?">; 
        float f2[5];
        uint data6[count6*count7] <comment="X*Y data">;
    }

    Vec4f last1 <comment="Not sure">;
    Vec4f last2 <comment="Not sure">;
};

// WATER_CHILD (Legacy)
struct WaterChildLayerData(uint64 endOffset) {
    Vec3f position <comment="Origin">;
    
    uint unk2 <comment="0, 2 observed. doesn't seem to be a count.">; 
    uint always_1 <comment="No other values than 1 observed.">;
    uint flags <comment="Usage of first 3 bits observed, affects the amount of unk_flagdata present.">;
    
    if (flags & 0x01)
    {
        unk_WaterFlagData fd_1;
    }

    if (flags & 0x02)
    {
        unk_WaterFlagData fd_2[2];
    }    

    if (flags & 0x04)
    {
        // 0.25, 0.5, 0.75, 1
        unk_WaterFlagData fd_3[4];
    }

    Vec3f textureScale <comment="Texture scaling related">;

    uint data1_count;
    Vec3f data1[data1_count] <read=Vec3fDisplay>;

    uint data2_count;
    Vec2f data2[data2_count] <read=Vec2fDisplay>;

    uint data3_count;
    uint data3[data3_count];

    uint data4_count;
    uint data4[data4_count];

    uint data5_count;
    uint data5[data5_count] <comment="Some indexing or mapping data">;
    
    uint waterdesc_sdb_id;

    byte moreData <comment="Seems to be a bool">;
    if (moreData > 0x00) {
        int count6 <comment="Some x?">; 
        uint count7 <comment="Some y?">; 
        float f2[5];
        uint data6[count6*count7] <comment="X*Y data">;
    }
    
    if (FTell() < endOffset) {
        // Not present in 1710
        uint always_zero <comment="No other values than 0 observed.">;
    }
};

// CHUNK_INFO_RANGE
struct ChunkZoneRangeLayerData {
    uint32 cubeface;
    uint32 min_chunk_x;
    uint32 max_chunk_x;
    uint32 min_chunk_y;
    uint32 max_chunk_y;
};

// CHUNK_INFO_REF
struct ChunkRefLayerData {
    uint32 chunk_x;
    uint32 chunk_y;
    uint32 chunk_record_id;
};

// CHUNK_INFO_REF2
struct ChunkRef2LayerData {
    uint32 chunk_x;
    uint32 chunk_y;
};

// MELDING_PERIMITER
struct MeldingPerimiterSetLayerData {
    uint32 nameLen<hidden=true>;
    char name[nameLen];
    uint32 controlPoints;
    uint32 bitfieldBitLength;
    byte bitfield[Ceil(bitfieldBitLength/8.0)];
    uint32 unk1;
    uint32 perimiterCount<hidden=true>;
    LengthDefinedString perimiters[perimiterCount] <optimize=false>;
        
    byte unk2;
    if (unk2 != 0) {
        //DataUnkBytes data(8)<name="UnknownData3">;
    }
};

// ZONE_135168
// Bounds but what for?
struct Zone_135168_LayerData {
    Vec3f min;
    Vec3f max;
};

// ZONE_SKYBOX
struct SkyBoxRecordLayerData {
    uint skybox_record_id;
};

// ZONE_PATH
struct PathStep {
    Vec3f position;
    Vec4f orientation;
    uint actionLen<hidden=true>;
    if (actionLen > 0) {   
        char action[actionLen];
    }
};

struct PathLayerData {
    uint cce_id;
    uint unk1;
    uint stepsCount<hidden=true>;
    PathStep steps[stepsCount] <optimize=false>;
};

// ZONE_PROP_ENCOUNTER_NAME_REGISTRY
// Does it also go for Chunk?
struct PropEncounterNameRegistryLayerData {
    uint32 propCount<hidden=true>;
    LengthDefinedString propNames[propCount] <optimize=false>;
};

// ZONE_CAMERA_SEQUENCE
struct CameraSequenceLayerData {
    // WIP
    uint cce_id;
    byte unk1;
    uint nameLen<hidden=true>;
    char name[nameLen];
    
    Vec3f vec1;
    Vec3f vec2;
    Vec3f vec3;
    Vec3f vec4;

    ushort cameraNodesCount;
    ushort cameraShotsCount;
    ushort cameraShakesCount;
    ushort cameraFadesCount;
    ushort colorGradingsCount;
    ushort npcsCount;
    ushort dialogScriptsCount;
    ushort soundEventsCount;
    ushort pfxsCount;
    ushort lightsCount;
    
    struct CameraNode {
        uint nameLen<hidden=true>;
        if (nameLen > 0)
            char name[nameLen];
        Vec3f vec1;
        Vec3f vec2;
        Vec3f vec3;
        Vec3f vec4;
    
        uint unk1;
        if (unk1 == 5) {
            uint targetBone1Len<hidden=true>;
            char targetBone1[targetBone1Len]; // guess
            
            DataUnkBytes data(18)<name="UnknownDataCameraNode_1">;
            
            uint targetBone2Len<hidden=true>;
            char targetBone2[targetBone2Len]; // guess    
            
            DataUnkBytes data(30)<name="UnknownDataCameraNode_2">;
           
        }
        else {
            DataUnkBytes data(56)<name="UnknownDataCameraNode">;
        }
    };
    if (cameraNodesCount > 0)
        CameraNode cameraNodes[cameraNodesCount] <optimize=false>;

    struct CameraShot {
        uint nameLen<hidden=true>;
        char name[nameLen];
        DataUnkBytes data(33)<name="UnknownDataCameraShot">;
    };
    if (cameraShotsCount > 0)
        CameraShot cameraShots[cameraShotsCount] <optimize=false>;
    
    struct CameraShake {
        uint nameLen<hidden=true>;
        char name[nameLen];
        DataUnkBytes data(46)<name="UnknownDataCameraShake">;
    };
    if (cameraShakesCount > 0)
        CameraShake cameraShakes[cameraShakesCount] <optimize=false>;
    
    struct CameraFade {
        uint nameLen<hidden=true>;
        char name[nameLen];
        DataUnkBytes data(34)<name="UnknownDataCameraFade">;
    };
    if (cameraFadesCount > 0)
        CameraFade cameraFades[cameraFadesCount] <optimize=false>;

    // TODO: ColorGrading

    // WIP: NPC
    /*
    struct NPC {
       uint nameLen<hidden=true>;
       char name[nameLen];

       uint unk1;
        
       // not that sure about these vecs, mostly just stepping forward
       Vec3f vec1;
       Vec3f vec2;
       Vec3f vec3;
       Vec3f vec4;
       
       ushort unk2_MeshComponentRefCount;
       struct unk_MeshComponentRef {
         uint str1Len<hidden=true>;
         char str1[str1Len];
         DataUnkBytes data(4)<name="UnknownDataMeshComponentRef">;
       };
       unk_MeshComponentRef unk_MeshComponentRefs[unk2_MeshComponentRefCount] <optimize=false>;
    
       ushort unk3_MaybeContentFlags; // actions or something?
       if (unk3_MaybeContentFlags > 0) {
         if (unk3_MaybeContentFlags == 2) {
            uint unk4;
            ushort unk5;
            ushort unk6;
            ushort unk7;
            ushort unk7_2;
            float unk8;
            ushort unk9;
            uint str10Len;
            char str10[str10Len];
         }
         else if (unk3_MaybeContentFlags == 4) {
            uint unk4;
            ushort unk5;
            ushort unk6;
            ushort unk7;
            float unk8;
            ushort unk9;
            uint str10Len;
            char str10[str10Len];
         }
       }
       
    };
    if (npcsCount > 0) {
        NPC npcs[npcsCount] <optimize=false>;
    }
    */
    // TODO: DialogEvents
    // TODO: SoundEvents
    // TODO: PFXs
    // TODO: Lights
};

// ZONE_TRANSFER_BOUNDS
struct ZoneTransferBoundsLayerData {
    // WIP
    uint32 zoneID;
    uint32 unk1;
    // ...
};

// COLLISION
//============================
struct GeoVertData {
    uint vertCount;
    Vec3f verts[vertCount] <read=Vec3fDisplay>;
};

struct indiceType1 {
    ushort a;
    ushort b;  
    ushort c;
};

struct indiceType2 {
    byte a;
    byte b;
    byte c;
};

struct indiceBlock {
    uint count;
    uint indiceType;

    if (indiceType == 393218) {
        indiceType1 indices[count];
    }
    else if (indiceType == 196609) {
        indiceType2 indices[count];
    }
};

struct matsDataBlock {
    uint count;
    uint id; // Might be type as well?
    byte data[count];
};

struct moppDataBlock {
    float floats[4];
    uint size;
    byte data[size];

    byte unk1;
    ushort unk2;

    uint numShorts;
    ushort shorts[numShorts];
};

// CHUNK_COLLISION
struct CollisionGeometryLayerData(uint nodeSize) {
    local uint startPos = FTell();    

    uint magic;
    ushort version; // ? should be 3
    ushort revision; // ? checked if less than 5
    uint id; // seems like a unique id

    uint numPhysicsMatIds;
    uint physicsMatIds[numPhysicsMatIds];
    
    if (revision == 2) {
        struct GeoBlockStorage {
            uint numVertBlocks;
            if (numVertBlocks > 0)
                GeoVertData vertBlocks[numVertBlocks] <optimize=false>;
    
            uint numIndiceBlocks;
            if (numIndiceBlocks > 0)
                indiceBlock indiceBlocks[numIndiceBlocks] <optimize=false>;
    
            uint numMatItems;
            if (numMatItems > 0)
                matsDataBlock matBlocks[numMatItems] <optimize=false>;
    
            uint numMoppBlocks;
            if (numMoppBlocks > 0)
                moppDataBlock moppBlocks[numMoppBlocks] <optimize=false>;
        } store <read=GeoStoreDisplay>;
    }
    
    local uint endPos = FTell(); 
    local uint remaining = nodeSize - (endPos - startPos);
    byte embeddedHavokBinaryTagfile[remaining]<comment="Use AssetCc2 to convert this to .xml">;
};

string GeoStoreDisplay(GeoBlockStorage &store)
{
    string s;   
    SPrintf( s, "Vert: %i, Indice: %i, Mat: %i, Mopp: %i", store.numVertBlocks, store.numIndiceBlocks, store.numMatItems, store.numMoppBlocks);
    return s;
}
//============================

// CHUNK_SUBZONEGRID
struct SubZoneGridData {
    uint unk1; // maybe some sort of flags
    uint unk2_gridsize; // 64
    uint subzone_ids_count;
    uint subzone_ids[subzone_ids_count];
    uint unk4_gridcount;
    byte grid_data[(unk2_gridsize*unk2_gridsize) * unk4_gridcount];
};

// CHUNK_VEGETATION2
struct VegationChunk2Data {
    Vec3f a;
    uint unk1;
    uint unk2;
    struct unkVegData1 {
        uint i;
        float f;
        
    };
    unkVegData1 unk3[unk1];
    Vec3f b[unk1];
};

// CHUNK_GEOMETRY
// CHUNK_GEOMETRY2
struct GeometryTreeBlock(uint32 type) {
    ushort count_entries; // Tied to chunk sections, eg high lod sub chunks have fewer entries per instance
    
    ushort const1; // "3"
    uint const2;   // "8"
    uint const3;   // "64"

    struct GeometryTreeEntry(uint32 type) {
        uint idx; // chunk node index
        uint count1; // cpu nodes?
        if (count1 > 0) {
            struct count1Data(uint32 type) {
                Vec3f min<read=Vec3fDisplay>;
                Vec3f max<read=Vec3fDisplay>;
                
                if (type == CHUNK_GEOMETRY) {
                    uint64 unkLong<format=hex>; // ?
                }

                uint count_inner;
                if (count_inner > 0) {
                    struct innerData(uint32 type) {
                        uint materialId : 24; // 3 lowest bytes, .tmlt
                        uint errorIfZero: 8; // 4th byte must not be zero

                        uint textureId1; // optional .r5tex
                        uint textureId2; // optional .r5tex
                        uint textureId3; // optional .r5tex
                        
                        if (type == CHUNK_GEOMETRY2) {
                            Vec3f center<read=Vec3fDisplay>; // ?
                            float extrafloat; // ?
                        }
        
                        Vec3f min<read=Vec3fDisplay>;
                        Vec3f max<read=Vec3fDisplay>;
                        
                        ushort unk1_1;
                        ushort unk1_2; // node/leaf count of some form
                        uint unk2; // ? might ref count 2 data
       
                        uint transformCount;
                        Matrix4x4 transform[transformCount]<optimize=false>;
                        
                        uint lz77_data1_num;
                        uint lz77_data1_compressedSize;
                        byte lz77_data1_uniqueIdx[lz77_data1_compressedSize]<comment="compressed">; // vgeo page/vert ref
                        
                        uint lz77_data2_num;
                        uint lz77_data2_compressedSize;
                        byte lz77_data2_xformIdx[lz77_data2_compressedSize]<comment="compressed">; // specifies which transform to use for a vertice
            
                        if (unk1_2 == 8) {
                            uint lz77_data6_num;
                            uint lz77_data6_compressedSize;
                            byte lz77_data6[lz77_data6_compressedSize]<comment="compressed">; // maybe xformN
                        }
                        
                        uint num; // 3*tris
                        short lz77_data3_offset;
                        uint lz77_data3_num;
                        uint lz77_data3_compressedSize;
                        if (lz77_data3_num > 0)
                            byte lz77_data3_repeatIdx[lz77_data3_compressedSize]<comment="compressed">;
        
                        uint lz77_data4_num;
                        uint lz77_data4_compressedSize;
                        byte lz77_data4_vertIndex[lz77_data4_compressedSize]<comment="compressed">;
                        
                        uint lz77_data5_repTblNum; // num/3
                        uint lz77_data5_compressedSize;
                        byte lz77_data5_triangles[lz77_data5_compressedSize]<comment="compressed">; // specifies how to form triangles from vertices
        
                        uint unk10; // ? might ref count 2 data
                    };
                    innerData inner_data(type)[count_inner]<optimize=false>;
                }
            };
            count1Data c1data(type)[count1]<optimize=false>;
        }

        uint count2; // gpu nodes?
        if (count2 > 0) {
            struct count2Data(uint32 type) {
                float endtenfloats[10];

                if (type == CHUNK_GEOMETRY) {
                    uint64 unkLong<format=hex>; // ?
                }
                int unk1;
                int unk2;
            };
            count2Data c2data(type)[count2]<optimize=false>;
        }

    };
    GeometryTreeEntry entries(type)[count_entries]<optimize=false>;
};

// TERRAIN
//============================
// CHUNK_TERRAIN
struct TerrainChunk_type0 {
    uint unk1;
    uint unk2;
    uint unk3;
    Vec3f vec; 
};

struct TerrainChunk_type3 {
    uint count;
    uint data[count];
};

struct TerrainChunk_type4(uint nodeSize) {
    uint nodeCount;
    struct T4Node {
        uint nodeIndex; // node index within a level
        uint nodeLevel; // node.mLevel <= cTerrainMaxChunkNodeLevel
        uint unk3; // flags?

        Vec3f matrix[3] <read=Vec3fDisplay>;
        float unk7;

        Vec3f boundsMin <read=Vec3fDisplay>;
        Vec3f boundsMax <read=Vec3fDisplay>;

        uint unk9; // Number of vertices?
        if (unk9 > 0) {
            byte unk10[16]; // ?

            uint unk11; // (unk15 * 3)
            ushort unk12;
    
            uint unk14_count;
            if (unk14_count != 0xffffffff) { // when node level is not 0?
                ushort unk14[unk14_count];
            }
        
            uint unk15; // Number of patch triangles?
        }

        byte haveMoreData;
        if (haveMoreData > 0) {
            uint materials[6]; // refmap?
            uint unk18_size; // client will attempt to allocate this number of bytes
        }
    };
    T4Node nodes[nodeCount] <read=T4NodeDisplay, optimize=false>;
    
    // this consumes all the bytes, but the divied up sections dont quite seem right when the count isn't 1
    struct T4NodeData_1(uint unk9, uint unk11) {
        byte sculpt_data[ 8 * (2 * unk9) ];
        byte lighting_data[ 6 * (unk9) ];
        byte data3[ (unk11 - 1) ];
        byte data4[ (unk11 - 1) ];
    };
    struct T4NodeData_2(uint unk18_size) {
        byte texturing_data[ unk18_size ]; 
    };
    local uint i;
    for (i = 0; i < nodeCount; i++) {
        if (nodes[i].unk9 > 0) {
            T4NodeData_1 t4nd1(nodes[i].unk9, nodes[i].unk11) <optimize=false>;
        }

        if (exists(nodes[i].unk18_size)) {
            T4NodeData_2 t4nd2(nodes[i].unk18_size) <optimize=false>;
        }
    }
};

string T4NodeDisplay(T4Node &node)
{
    string s;   
    SPrintf( s, "Index: %i, Level: %i", node.nodeIndex, node.nodeLevel);
    return s;
}

struct TerrainChunk_QuadTreeData(uint nodeSize) {
    byte unk[8];
};
//============================

// PROP_DOODAD
struct DoodadLayerData {
    uint32 prop_record_id;
    Vec4f transform[4];
    uint32 unk3;
    uint32 unk4;
    int32 unk5;
    int32 unk6;
    int32 unk7;
    int32 unk8;
    float unk9[5];
};

// PROP_LIGHTDATA
struct PropNodeEntry_LightData {
    byte header[64];
    uint unk1;
    float unk2[6];
    uint unk4;
};

// PROP_AUDIOVOLUME
struct PropNodeEntry_AudioVolume {
    Vec4f floats1<read=Vec4fDisplay>;
    Vec4f floats2<read=Vec4fDisplay>;
    Vec4f floats3<read=Vec4fDisplay>;
    uint unk1;
    Vec4f floats4<read=Vec4fDisplay>;
    byte last[9];
};

// PROP_DECALINSTANCES2
struct PropNodeEntry_DecalInstances2 {
    uint decal_id;
    Matrix3x4 transform;
    byte last[3];
};

// PROP_PARTICLEDATA
struct PropNodeEntry_ParticleData {
    uint unk1;
    Vec4f a<read=Vec4fDisplay>;
    Vec4f b<read=Vec4fDisplay>;
    Vec4f c<read=Vec4fDisplay>;
    Vec4f b<read=Vec4fDisplay>;
    uint unk2;
    byte last[20];
};

// ENVIRONMENT
//============================
struct CommonEnvStruct1 { // FUN_0170b5f0
    uint haveData;
    if (haveData == 1) {
        uint count;
        // some init condition here
        float unk3[2*count]; // do while here
    };
};

struct CommonEnvStruct2(char param3, byte param4) { // FUN_017009e0
    struct TypeZero {
        float unk3;
        ubyte argb[4]; // Guessing this is color as ARGB looks to fit
    };
    
    struct TypeOther {
        float unk3;
        byte unk5[3];
        float unk6;
    };
    
    uint haveData;
    if (haveData == 1) { // some additional check here
        uint count;
        if (param4 == 0) {
            TypeZero data[count];
        } else {
            TypeOther data[count];
        }
    };
};

struct CommonEnvShared3 {
    CommonEnvStruct1 unk1;
    CommonEnvStruct2 unk2('\0',0);
    CommonEnvStruct1 unk3;
    CommonEnvStruct1 unk4;
    CommonEnvStruct1 unk5;
};

// DEFAULT_ENVIRONMENT_10000
struct DefaultEnvironment_10000_LayerData(uint64 layerDataEndPos) {
    Vec3f unk1;
    if (FTell() < layerDataEndPos) {
        Vec3f unk2;
    }
};

// ENVIRONMENT_0031
struct Environment_0031_LayerData {
    CommonEnvStruct2 unk1('\0',0);
    CommonEnvShared3 unk4;
};

// ENVIRONMENT_0032
struct Environment_0032_LayerData {
    CommonEnvStruct2 unk1('\0',0);
    CommonEnvStruct1 unk2;
    CommonEnvStruct1 unk3;
    CommonEnvShared3 unk4;
};

// ENVIRONMENT_0033
struct Environment_0033_LayerData(uint64 layerDataEndPos) {
    CommonEnvStruct2 unk1('\x01',0);
    CommonEnvStruct1 unk2;
    CommonEnvStruct1 unk3;
    CommonEnvStruct1 unk4;
    CommonEnvStruct2 unk5('\x01',0);
    CommonEnvStruct1 unk6;
    CommonEnvStruct1 unk7;
    CommonEnvStruct1 unk8;
    
    if (FTell() < layerDataEndPos) {
        CommonEnvStruct1 unk9;
        CommonEnvStruct1 unk10;
        CommonEnvStruct1 unk11;
    }
    
    if (FTell() < layerDataEndPos) {
        CommonEnvStruct1 unk12;
        CommonEnvStruct1 unk13;
    }
};

// ENVIRONMENT_0034
struct Environment_0034_LayerData {
    CommonEnvStruct2 unk1('\x01',1);
    CommonEnvStruct1 unk2;
    CommonEnvStruct2 unk3('\x01',1);
    CommonEnvStruct1 unk4;
    CommonEnvStruct2 unk5('\x01',1);
    CommonEnvStruct1 unk6;
    CommonEnvStruct1 unk7;
    CommonEnvStruct1 unk8;
    CommonEnvStruct1 unk9;
    CommonEnvStruct2 unk10('\x01',0);
    CommonEnvStruct1 unk11;
    CommonEnvStruct1 unk12;
    CommonEnvStruct1 unk13;
    CommonEnvStruct1 unk14;
    CommonEnvStruct1 unk15;
    CommonEnvStruct1 unk16;
    CommonEnvStruct1 unk17;
};

// ENVIRONMENT_0202
struct Environment_0202_LayerData {
    CommonEnvStruct2 unk1('\0',0);
    CommonEnvStruct2 unk2('\0',0);
};

// ENVIRONMENT_0203
struct Environment_0203_LayerData {
    CommonEnvStruct2 unk1('\x01',0);
    CommonEnvStruct2 unk2('\x01',0);
    CommonEnvStruct1 unk3;
};

// ENVIRONMENT_0302
struct Environment_0302_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct2 unk2('\0',0);
    CommonEnvStruct2 unk2('\0',0);
};

// ENVIRONMENT_0303
struct Environment_0303_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct2 unk2('\0',0);
};

// ENVIRONMENT_0304
struct Environment_0304_LayerData(uint64 layerDataEndPos) {
    CommonEnvStruct1 unk1;
    CommonEnvStruct2 unk2('\x01',0);
    CommonEnvStruct2 unk3('\x01',0);
    
    if (FTell() < layerDataEndPos) {
        CommonEnvStruct1 unk4;
    }
};

// ENVIRONMENT_0400
struct Environment_0400_LayerData {
      Vec3f unk1;
      float unk2;
      float unk3;
      float unk4;
};

// ENVIRONMENT_0401
struct Environment_0401_LayerData(uint64 layerDataEndPos) {
    Matrix4x4 transform;
    float unk1;
    float unk2;
    uint unk3;
    
    // Weird call parsing up to 3 values maybe
    uint unk4_1;
    uint unk4_2;
    uint unk4_3;
    
    if (FTell() == layerDataEndPos-1) {
        byte unk5;
    } else {
        if (FTell() < layerDataEndPos) {
            uint unk6;
        }
        if (FTell() < layerDataEndPos) {
            uint unk7;
        }
    }
};

// ENVIRONMENT_0501
struct Environment_0501_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct1 unk2;
};

// ENVIRONMENT_0600
struct Environment_0600_LayerData {
    CommonEnvStruct2 unk1('\0',0);
    CommonEnvStruct2 unk2('\0',0);
    CommonEnvStruct2 unk3('\0',0);
    CommonEnvStruct2 unk4('\0',0);
    CommonEnvStruct2 unk5('\0',0);
};

// ENVIRONMENT_0601 (Good fit for Clouds, 5 colors!)
struct Environment_0601_LayerData {
    CommonEnvStruct2 unk1('\x01',0);
    CommonEnvStruct2 unk2('\x01',0);
    CommonEnvStruct2 unk3('\x01',0);
    CommonEnvStruct2 unk4('\x01',0);
    CommonEnvStruct2 unk5('\x01',0);
};

// ENVIRONMENT_0700
struct Environment_0700_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct1 unk2;
};

// ENVIRONMENT_0800
struct Environment_0800_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct1 unk2;
};

// ENVIRONMENT_0900
struct Environment_0900_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct1 unk2;
};

// ENVIRONMENT_1000
struct Environment_1000_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct2 unk2('\x01',0);
};

// ENVIRONMENT_1100
struct Environment_1100_LayerData {};

// ENVIRONMENT_1200
struct Environment_1200_LayerData {
    CommonEnvStruct1 unk1;
    CommonEnvStruct1 unk2;
    CommonEnvStruct1 unk3;
    CommonEnvStruct1 unk4;
    CommonEnvStruct1 unk5;
};

// ENVIRONMENT_1300
// 7(8) floats + 2 bools = good fit for Effect Weights
struct Environment_1300_LayerData(uint64 layerDataEndPos) {
    float unk1;
    float unk2;
    float unk3;
    float unk4;
    float unk5;
    float unk6;

    if (FTell() < layerDataEndPos) {
        float unk7;
    }
    if (FTell() < layerDataEndPos) {
        byte unk8;
    }
    if (FTell() < layerDataEndPos) {
        byte unk9;
    }
    if (FTell() < layerDataEndPos) {
        float unk10;
    }
};

// ENVIRONMENT_1400
struct Environment_1400_LayerData(uint64 layerDataEndPos) {
    uint unk1;
    
    if (FTell() < layerDataEndPos) {
        uint unk2;
    }
};
//============================

//============================
//============================

// Main layer structure
struct Layer;
typedef struct (LayerType parentTypeId) {
    // Parse layer header
    local LayerType parentType<hidden=true> = parentTypeId;
    uint64 magicTag<hidden=true>;
    if (magicTag != NODE_TAG_MAGIC) {
        Printf("Error, Layer magic missmatch");
    }
    LayerType typeId<format=hex>;
    local string typeDisplayName = GetLayerTypeDisplayName(parentType, typeId);
    uint32 length;
    local uint64 layerContentStartPos<hidden=true> = FTell();
    local uint64 layerContentEndPos<hidden=true> = layerContentStartPos + length;

    // Prescan to find how much of our length that is data as opposed to children
    local uint64 layerDataEndPos<hidden=true> = 0;
    local uint64 nextLayerTagPos<hidden=true> = FindFirst(NODE_TAG_MAGIC, true, false, 0, 0.0, 1, layerContentStartPos);        
    if (nextLayerTagPos == -1) {
        // No next tag, so no more nodes
        layerDataEndPos = layerContentEndPos;
    }
    else {
        layerDataEndPos = nextLayerTagPos;
    }
    
    // If there is layer data to parse
    if (layerDataEndPos > layerContentStartPos) {
        // Handle per type data 
       
        // Terrain children separated to avoid ID conflicts
        if (parentTypeId == CHUNK_TERRAIN) {
            switch (typeId) {
                case TERRAIN_T0:
                    TerrainChunk_type0 data<optimize=false>;
                    break;
                case TERRAIN_QUADTREE:
                    TerrainChunk_QuadTreeData data(length)<optimize=false>;
                    break;
                case TERRAIN_T3:
                    TerrainChunk_type3 data<optimize=false>;
                    break;
                case TERRAIN_T4:
                    TerrainChunk_type4 data(length)<optimize=false>;
                    break;
                default:
                    break;
            }
        }
        // Handle remaining independent of parent
        else {
            switch (typeId) {
                case CHUNK:
                    ChunkRootLayerData data;
                    break;
        
                case CHUNK_LOD:
                    ChunkLodLayerData data;
                    break;
        
                case CHUNK_SUBCHUNK:
                    ChunkSubChunkLayerData data;
                    break;
        
                case ZONE_WATER:
                    WaterLayerData data;
                    break;
        
                case CHUNK_WATER:
                    WaterLayerData data;
                    break;
        
                case WATER_CHILD:
                    WaterChildLayerData data(layerContentEndPos);
                    break;
        
                case ZONE_SKYBOX:
                    SkyBoxRecordLayerData data;
                    break;
                
                case MELDING_PERIMITER:
                    MeldingPerimiterSetLayerData data;
                    break;
        
                case ZONE_PATH:
                    PathLayerData data;
                    break;
        
                case CHUNK_INFO_RANGE:
                    ChunkZoneRangeLayerData data;
                    break;
        
                case CHUNK_INFO_REF:
                    ChunkRefLayerData data;
                    break;
        
                case CHUNK_INFO_REF2:
                    ChunkRef2LayerData data;
                    break;
        
                case ZONE_CAMERA_SEQUENCE:
                    CameraSequenceLayerData data;
                    break;
                
                case ZONE_TRANSFER_BOUNDS:
                    ZoneTransferBoundsLayerData data;
                    break;
        
                case ZONE_PROP_ENCOUNTER_NAME_REGISTRY:
                    PropEncounterNameRegistryLayerData data;
                    break;
       
                case ZONE_135168:
                    Zone_135168_LayerData data;
                    break;
        
                case DEFAULT_ENVIRONMENT_10000:
                    DefaultEnvironment_10000_LayerData data(layerDataEndPos);
                    break;
        
                case CHUNK_COLLISION1:
                    CollisionGeometryLayerData data(length);
                    break;
                case CHUNK_COLLISION2:
                    CollisionGeometryLayerData data(length);
                    break;
                case CHUNK_COLLISION3:
                    CollisionGeometryLayerData data(length);
                    break;
                case ZONE_WORLD_CHUNK_IMPORT:
                    CollisionGeometryLayerData data(length);
                    break;
                
                case CHUNK_GEOMETRY:
                    GeometryTreeBlock data(typeId);
                    break;

                case CHUNK_GEOMETRY2:
                    GeometryTreeBlock data(typeId);
                    break;

                case CHUNK_SUBZONEGRID:
                    SubZoneGridData data;
                    break;

                case CHUNK_VEGETATION2:
                    // VegationChunk2Data data;
                    break;
                
                case PROP_DOODAD:
                    DoodadLayerData data;
                    break;                

                case PROP_LIGHTDATA:
                    PropNodeEntry_LightData data;
                    break;

                case PROP_AUDIOVOLUME:
                    PropNodeEntry_AudioVolume data;
                    break;

                case PROP_DECALINSTANCES2:
                    PropNodeEntry_DecalInstances2 data;
                    break;

                case PROP_PARTICLEDATA:
                    PropNodeEntry_ParticleData data;
                    break;
                
                case ENVIRONMENT_0031:
                    Environment_0031_LayerData data;
                    break;
                    
                case ENVIRONMENT_0032:
                    Environment_0032_LayerData data;
                    break;
                
                case ENVIRONMENT_0033:
                    Environment_0033_LayerData data(layerDataEndPos);
                    break;

                case ENVIRONMENT_0034:
                    Environment_0034_LayerData data;
                    break;

                case ENVIRONMENT_0202:
                    Environment_0202_LayerData data;
                    break;

                case ENVIRONMENT_0203:
                    Environment_0203_LayerData data;
                    break;
                    
                case ENVIRONMENT_0302:
                    Environment_0302_LayerData data;
                    break;
                    
                case ENVIRONMENT_0303:
                    Environment_0303_LayerData data;
                    break;

                case ENVIRONMENT_0304:
                    Environment_0304_LayerData data(layerDataEndPos);
                    break;

                case ENVIRONMENT_0401:
                    Environment_0401_LayerData data(layerDataEndPos);
                    break;

                case ENVIRONMENT_0501:
                    Environment_0501_LayerData data;
                    break;

                case ENVIRONMENT_0601:
                    Environment_0601_LayerData data;
                    break;

                case ENVIRONMENT_0700:
                    Environment_0700_LayerData data;
                    break;

                case ENVIRONMENT_0800:
                    Environment_0800_LayerData data;
                    break;

                case ENVIRONMENT_0900:
                    Environment_0900_LayerData data;
                    break;

                case ENVIRONMENT_1000:
                    Environment_1000_LayerData data;
                    break;

                case ENVIRONMENT_1100:
                    Environment_1100_LayerData data;
                    break;

                case ENVIRONMENT_1200:
                    Environment_1200_LayerData data;
                    break;

                case ENVIRONMENT_1300:
                    Environment_1300_LayerData data(layerDataEndPos);
                    break;

                case ENVIRONMENT_1400:
                    Environment_1400_LayerData data(layerDataEndPos);
                    break;

                default:
                    break;
            }
        }
    }

    // Ensure that we have parsed all the data of the layer before parsing children
    local uint64 finishedParsingDataPos<hidden=true> = FTell();
    if (finishedParsingDataPos != layerContentEndPos) {
        if (finishedParsingDataPos > layerContentEndPos) {
            Printf("Error, parsed beyond Layer length");
        }

        // Determine how much we have left based on next node or end of file.
        local uint64 remaining<hidden=true> = 0;
        if (nextLayerTagPos == -1) {
            // No next tag, so no more nodes
            remaining = FileSize() - finishedParsingDataPos;
        }
        else if (finishedParsingDataPos != nextLayerTagPos) {
            // We are not at the next node, so we must not have finished parsing all the data
            remaining = nextLayerTagPos - finishedParsingDataPos;
        }
        if (remaining > 0) {
            byte unparsedData[remaining];
        }
    }

    // Parse children if we have remaining content
    local uint64 postParsingDataPos<hidden=true> = FTell();
    if (postParsingDataPos != layerContentEndPos) {
        while( FTell() < layerContentEndPos ) {
            Layer child(typeId);
        }
    }
} Layer<read=LayerDisplay>;

string GetLayerTypeDisplayName(LayerType parent, LayerType typeId) {
    local string v = EnumToString(typeId);
    
    // Collision on id 0
    if (parent == TERRAIN_QUADTREE_BLENDWEIGHT && typeId == TERRAIN_QUADTREE_BLENDWEIGHT_0) {
        v = "TERRAIN_QUADTREE_BLENDWEIGHT_0";
    }
    else if (parent == CHUNK_TERRAIN && typeId == TERRAIN_T0) {
        v = "TERRAIN_T0";
    }
    
    // Collision on id 4
    if (parent == CHUNK_TERRAIN && typeId == TERRAIN_T4) {
        v = "TERRAIN_T4";
    }
    else if (parent == ZONE_WATER && typeId == WATER_CHILD) {
        v = "WATER_CHILD";
    }

    // Collision on id 5
    if (parent == ZONE_MELDING && typeId == MELDING_PERIMITER) {
        v = "MELDING_PERIMITER";
    }
    else if (parent == TERRAIN_MATERIALS && typeId == TERRAIN_MATERIAL) {
        v = "TERRAIN_MATERIAL";
    }    

    return v;
}

string LayerDisplay(Layer &layer)
{
    string s;
    string v = GetLayerTypeDisplayName(layer.parentType, layer.typeId);
    SPrintf( s, "%s", v);
    return s;
}

#endif