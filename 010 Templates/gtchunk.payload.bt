//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: gtchunk compressed node
//   Authors: Arkii, Xsear
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint64 NODE_TAG_MAGIC = 0x12ED5A12ED5B12ED;

struct Node;

struct NodeHeader {
    uint64 magicTag<hidden=true>;
    uint nodeType;
    uint32 len;
};


struct vec3 {
    float x;
    float y;
    float z;
};


// Geometry Node Data
//============================

struct GeoVertData {
    uint vertCount;
    vec3 verts[vertCount] <read=Vec3Display>;
};

struct indiceType1 {
    ushort a;
    ushort b;  
    ushort c;
};

struct indiceType2 {
    byte a;
    byte b;
    byte c;
};

struct indiceBlock {
    uint count;
    uint indiceType;

    if (indiceType == 393218) {
        indiceType1 indices[count];
    }
    else if (indiceType == 196609) {
        indiceType2 indices[count];
    }
    
};

struct matsDataBlock {
    uint count;
    uint id; // Might be type as well?
    byte data[count];
};

struct moppDataBlock {
    float floats[4];
    uint size;
    byte data[size];

    byte unk1;
    ushort unk2;

    uint numShorts;
    ushort shorts[numShorts];
};

struct GeometryData(uint nodeSize) {
    local uint startPos = FTell();    

    uint magic;
    ushort version; // ? should be 3
    ushort revision; // ? checked if less than 5
    uint unk1; // seems like a unique id
    uint numPhysicsMatIds;
    uint physicsMatIds[numPhysicsMatIds];

    uint numVertBlocks;
    GeoVertData vertBlocks[numVertBlocks] <optimize=false>;

    uint numIndiceBlocks;
    indiceBlock indiceBlocks[numIndiceBlocks] <optimize=false>;

    uint numMatItems;
    matsDataBlock matBlocks[numMatItems] <optimize=false>;

    uint numMoppBlocks;
    moppDataBlock moppBlocks[numMoppBlocks] <optimize=false>;

    local uint endPos = FTell(); 
    local uint leftSize = nodeSize - (endPos - startPos);
    byte havokData[leftSize];
};

// Props Dode Data
//============================

struct PropsDataChunk(uint nodeSize) {
    local uint endOffset = FTell() + nodeSize;
    while( FTell() < endOffset ) {
        Node subNode<read=NodeDisplay>;
    }
};

struct PropNodeEntry_LightData {
    byte header[64];
    uint unk1;
    float unk2[6];
    uint unk4;
};

// Mesh instances ?
//============================

struct MeshInstanceBlock {
ushort count;
    ushort unk1;
    uint unk2;
    uint unk3;

    uint unk4;
    uint unk5;

    float unkFloat[6];
    uint64 unk6; // not on 262659 node id
    uint unk7;
    uint unk8;
    byte unk9[1100]; // some mat stuff sub_19B1220

    uint unk10;
};

// Terrain Chunk 
//============================

struct TerrainChunk_type0 {
    uint unk1;
    uint unk2;
    uint unk3;
    vec3 vec; 
};

struct TerrainChunk_type3 {
    uint count;
    uint data[count];
};

struct TerrainChunk_type4(uint nodeSize) {
    uint nodeCount;
    struct T4Node {
        uint nodeIndex; // node index within a level
        uint nodeLevel; // node.mLevel <= cTerrainMaxChunkNodeLevel
        uint unk3; // flags?

        vec3 matrix[3] <read=Vec3Display>;
        float unk7;

        vec3 boundsMin <read=Vec3Display>;
        vec3 boundsMax <read=Vec3Display>;

        uint unk9; // Number of vertices?
        if (unk9 > 0) {
            byte unk10[16]; // ?

            uint unk11; // (unk15 * 3)
            ushort unk12;
    
            uint unk14_count;
            if (unk14_count != 0xffffffff) { // when node level is not 0?
                ushort unk14[unk14_count];
            }
        
            uint unk15; // Number of patch triangles?
        }

        byte haveMoreData;
        if (haveMoreData > 0) {
            uint materials[6]; // refmap?
            uint unk18_size; // client will attempt to allocate this number of bytes
        }
    };
    T4Node nodes[nodeCount] <read=T4NodeDisplay, optimize=false>;
    
    // this consumes all the bytes, but the divied up sections dont quite seem right when the count isn't 1
    struct T4NodeData_1(uint unk9, uint unk11) {
        byte sculpt_data[ 8 * (2 * unk9) ];
        byte lighting_data[ 6 * (unk9) ];
        byte data3[ (unk11 - 1) ];
        byte data4[ (unk11 - 1) ];
    };
    struct T4NodeData_2(uint unk18_size) {
        byte texturing_data[ unk18_size ]; 
    };
    local uint i;
    for (i = 0; i < nodeCount; i++) {
        if (nodes[i].unk9 > 0) {
            T4NodeData_1 t4nd1(nodes[i].unk9, nodes[i].unk11) <optimize=false>;
        }

        if (exists(nodes[i].unk18_size)) {
            T4NodeData_2 t4nd2(nodes[i].unk18_size) <optimize=false>;
        }
    }
};

struct TerrainChunk(uint nodeSize) {
    local uint endOffset = FTell() + nodeSize;
    while( FTell() < endOffset ) {
        Node subNode<read=NodeDisplay>;
    }
};

// 
//============================


struct UnkNode1Data {
    ushort unk1; // a count?
    ushort unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    ushort unk6;

    struct UnkNode1SubData {
        uint idx;
        byte unk[8];
    };
    UnkNode1SubData unk1Data[unk1];
};

//============================

struct Node {
    uint64 magicTag<hidden=true>;
    enum <uint32> {
            Terrain          = 262400, // parent, children are "terrain chunk layer"
                Terrain_T0              = 0, // meta, init?
                TerrainChunk_Materials  = 1, // parent, children are "terrain chunk material layer"
                    TerrainChunk_MaterialLayer  = 5,
                Terrain_T2              = 2, // might be blend weight layer
                Terrain_T3              = 3, // list of terrain materials to load
                Terrain_T4              = 4, // shape data?
            Geometry         = 262401,
            SubZoneGrid      = 262402,
            Geometry3        = 262403,
            PropEncNameReg2  = 262404, // seen in shared lod data,  "chunk prop encounter name registry"
            Geometry2        = 262405,
            PropsNode        = 262656, // parent, children are "prop type layer"
                PropType_Doodad           = 327680, // same id as zone files, probably same parsing then
                PropType_EnvironmentData  = 327681, // environment prop data, these ids are also in the zone files
                    DefaultEnvironmentLayer_0034  = 34,
                    DefaultEnvironmentLayer_0203  = 203,
                    DefaultEnvironmentLayer_0304  = 304, 
                    DefaultEnvironmentLayer_0401  = 401, 
                    DefaultEnvironmentLayer_0501  = 501, 
                    DefaultEnvironmentLayer_0601  = 601, 
                    DefaultEnvironmentLayer_0700  = 700, 
                    DefaultEnvironmentLayer_0900  = 900, 
                    DefaultEnvironmentLayer_0800  = 800, 
                    DefaultEnvironmentLayer_1000  = 1000,
                    DefaultEnvironmentLayer_1200  = 1200,
                    DefaultEnvironmentLayer_1300  = 1300,
                    DefaultEnvironmentLayer_1400  = 1400,
                PropType_ProbeData        = 327686,
                PropType_DecalInstances1  = 327688,
                PropType_ParticleData     = 327693, // Bit unsure, seems like it should have children
                PropType_LightData        = 327697,
                PropType_AudioVolume      = 327700,
                PropType_Monster          = 327703,
                PropType_DecalInstances2  = 327704,
            UnkNode1         = 262659, // similiar to MeshInstance
            PropEncNameReg   = 262660, // "chunk prop encounter name registry"
            VegationChunk    = 262661,
            OverlayChunk     = 262662,
            SectorsChunk     = 262663,
                SectorsEntry    = 327699,
            WaterObjectChunk = 262664,
            VegationChunk2   = 262665,
            MeshInstance     = 262672
            
        } nodeType;
        uint32 len;

    local uint64 startPos = FTell();

    if (nodeType == Geometry || nodeType == Geometry2 || nodeType == Geometry3) {
        GeometryData data(len);
        byte geoLeftData[len - sizeof(data)];
    }
    else if (nodeType == Terrain) {
        TerrainChunk data(len) <optimize=false>;
    }
    else if (nodeType == Terrain_T4) {
        TerrainChunk_type4 data(len)<optimize=false>;
    }
    else if (nodeType == Terrain_T3) {
        TerrainChunk_type3 data<optimize=false>;
    }
    else if (nodeType == Terrain_T0) {
        TerrainChunk_type0 data<optimize=false>;
    }

    else if (nodeType == PropsNode) {
        PropsDataChunk data(len);
    }
    else if (nodeType == PropType_LightData) {
        PropNodeEntry_LightData data;
        local uint remaining = len - sizeof(data);
        if (remaining > 0) {
            byte leftData[remaining];
        }
    }
    else if (nodeType == MeshInstance) {
        MeshInstanceBlock data;
        local uint remaining = len - sizeof(data);
        if (remaining > 0) {
            byte leftData[remaining];
        }
    }
    else if (nodeType == UnkNode1) {
        UnkNode1Data data;
        local uint remaining = len - sizeof(data);
        if (remaining > 0) {
            byte leftData[remaining];
        }
    }
    else {
        byte data[len];
    }
};

while( FTell() < FileSize() ) {
    Node node<read=NodeDisplay>;
}

// display formating
string Vec3Display(vec3 &vec)
{
    string s;   
    SPrintf( s, "%f, %f, %f", vec.x, vec.y, vec.z );
    return s;
}

string NodeDisplay(Node &node)
{
    string s;   
    SPrintf( s, "%s", EnumToString(node.nodeType));
    return s;
}

string T4NodeDisplay(T4Node &node)
{
    string s;   
    SPrintf( s, "Index: %i, Level: %i", node.nodeIndex, node.nodeLevel);
    return s;
}
