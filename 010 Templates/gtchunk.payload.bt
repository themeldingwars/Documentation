//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: gtchunk compressed node
//   Authors: Arkii, Xsear
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint64 NODE_TAG_MAGIC = 0x12ED5A12ED5B12ED;

struct Node;

struct NodeHeader {
    uint64 magicTag<hidden=true>;
    uint nodeType;
    uint32 len;
};


struct vec3 {
    float x;
    float y;
    float z;
};


// Geometry Node Data
//============================

struct GeoVertData {
    uint vertCount;
    vec3 verts[vertCount] <read=Vec3Display>;
};

struct indiceType1 {
    ushort a;
    ushort b;  
    ushort c;
};

struct indiceType2 {
    byte a;
    byte b;
    byte c;
};

struct indiceBlock {
    uint count;
    uint indiceType;

    if (indiceType == 393218) {
        indiceType1 indices[count];
    }
    else if (indiceType == 196609) {
        indiceType2 indices[count];
    }
    
};

struct matsDataBlock {
    uint count;
    uint id; // Might be type as well?
    byte data[count];
};

struct moppDataBlock {
    float floats[4];
    uint size;
    byte data[size];

    byte unk1;
    ushort unk2;

    uint numShorts;
    ushort shorts[numShorts];
};

struct GeometryData(uint nodeSize) {
    local uint startPos = FTell();    

    uint magic;
    ushort version; // ? should be 3
    ushort revision; // ? checked if less than 5
    uint unk1; // seems like a unique id
    uint numPhysicsMatIds;
    uint physicsMatIds[numPhysicsMatIds];

    uint numVertBlocks;
    GeoVertData vertBlocks[numVertBlocks] <optimize=false>;

    uint numIndiceBlocks;
    indiceBlock indiceBlocks[numIndiceBlocks] <optimize=false>;

    uint numMatItems;
    matsDataBlock matBlocks[numMatItems] <optimize=false>;

    uint numMoppBlocks;
    moppDataBlock moppBlocks[numMoppBlocks] <optimize=false>;

    local uint endPos = FTell(); 
    local uint leftSize = nodeSize - (endPos - startPos);
    byte havokData[leftSize];
};

// Props Dode Data
//============================

struct PropsDataChunk(uint nodeSize) {
    while( FTell() < nodeSize ) {
        Node subNode;
    }
};

struct PropNodeEntry {
    byte header[64];
    uint unk1;
    float unk2[6];
    uint unk4;
};

// Mesh instances ?
//============================

struct MeshInstanceBlock {
ushort count;
    ushort unk1;
    uint unk2;
    uint unk3;

    uint unk4;
    uint unk5;

    float unkFloat[6];
    uint64 unk6; // not on 262659 node id
    uint unk7;
    uint unk8;
    byte unk9[1100]; // some mat stuff sub_19B1220

    uint unk10;
};

// Terrain Chunk 
//============================

struct TerrainChunk_type0 {
    uint unk1;
    uint unk2;
    uint unk3;
    vec3 vec; 
};

struct TerrainChunk_type3 {
    uint count;
    uint data[count];
};

struct TerrainChunk_type4(uint nodeSize) {
    uint count;

    uint unk1;
    uint unk2;
    uint unk3;
    float unk4[3];
    float unk5[3];
    float unk6[3];
    float unk7;
    vec3 boundsMin <read=Vec3Display>;
    vec3 boundsMax <read=Vec3Display>;
    uint unk9; // Number of vertices?
    byte unk10[16]; // Needs to be parsed
    uint unk11; // (Triangles/unk15 * 3)
    ushort unk12;
    uint unk13;
    
    if (unk13 != 0xffffffff) { // unk2 is 0?
        ushort unk14[unk13];
    }

    uint unk15; // Number of patch triangles?

    byte unk16; // probably related?
    uint materials[6];
    
    uint unk18_size; // client will attempt to allocate this number of bytes
};

struct TerrainChunk(uint nodeSize) {
    while( FTell() < nodeSize ) {
        NodeHeader header;
        if (header.nodeType == 4) {
            TerrainChunk_type4 data(header.len);
            byte dataLeft[header.len - sizeof(data)];
        }
        else if (header.nodeType == 3) {
            TerrainChunk_type3 data;
        }
        else if (header.nodeType == 0) {
            TerrainChunk_type0 data;
        }
        else {
            byte data[header.len];
        }
    }
};

// 
//============================


struct UnkNode1Data {
    ushort unk1; // a count
    ushort unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    ushort unk6;

    struct UnkNode1SubData {
        uint idx;
        byte unk[8];
    };
    UnkNode1SubData unk1Data[unk1];
};

//============================

struct Node {
    uint64 magicTag<hidden=true>;
    enum <uint32> {
            Terrain          = 262400, // parent for terrain
                Terrain_T0      = 0,
                Terrain_T1      = 1, // parent for T5
                    Terrain_T5      = 5,
                Terrain_T2      = 2,
                Terrain_T3      = 3, // list of terrain materials to load
                Terrain_T4      = 4,
            Geometry         = 262401,
            SubZoneGrid      = 262402,
            Geometry3        = 262403,
            UnkNode2         = 262404, // seen in shared lod data
            Geometry2        = 262405,
            PropsNode        = 262656,
                PropEntry5       = 327680,
                PropEntryParent  = 327681, // ? parent node within propchunk, looks like same children node types every time
                  PropEntryChild_0034  = 34,
                  PropEntryChild_0203  = 203,
                  PropEntryChild_0304  = 304, 
                  PropEntryChild_0401  = 401, 
                  PropEntryChild_0501  = 501, 
                  PropEntryChild_0601  = 601, 
                  PropEntryChild_0700  = 700, 
                  PropEntryChild_0900  = 900, 
                  PropEntryChild_0800  = 800, 
                  PropEntryChild_1000  = 1000,
                  PropEntryChild_1200  = 1200,
                  PropEntryChild_1300  = 1300,
                  PropEntryChild_1400  = 1400,
                PropEntry6       = 327686,
                PropEntry8       = 327688,
                PropEntry4       = 327693,
                PropEntry        = 327697,
                PropEntry3       = 327700,
                PropEntry7       = 327703,
                PropEntry2       = 327704,
            UnkNode1         = 262659, // similiar to MeshInstance
            PropEncNameReg   = 262660,
            VegationChunk    = 262661,
            OverlayChunk     = 262662,
            SectorsChunk     = 262663,
                SectorsEntry    = 327699,
            WaterObjectChunk = 262664,
            VegationChunk2   = 262665,
            MeshInstance     = 262672
            
        } nodeType;
        uint32 len;

    local uint64 startPos = FTell();

    if (nodeType == Geometry || nodeType == Geometry2 || nodeType == Geometry3) {
        GeometryData data(len);
        byte geoLeftData[len - sizeof(data)];
    }
    else if (nodeType == Terrain) {
        TerrainChunk data(len);
        //byte leftData[len - sizeof(data)];
    }
    else if (nodeType == PropsNode) {
        PropsDataChunk data(startPos + len);
    }
    else if (nodeType == PropEntry) {
        PropNodeEntry entry;
        byte leftData[len - sizeof(entry)];
    }
    else if (nodeType == MeshInstance) {
        MeshInstanceBlock data;
        byte leftData[len - sizeof(data)];
    }
    else if (nodeType == UnkNode1) {
        UnkNode1Data data;
    }
    else {
        byte data[len];
    }
};

while( FTell() < FileSize() ) {
    Node node ;
}

// display formating
string Vec3Display(vec3 &vec)
{
    string s;   
    SPrintf( s, "%f, %f, %f", vec.x, vec.y, vec.z );
    return s;
}
