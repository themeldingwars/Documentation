//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: gtchunk compressed node
//   Authors: Arkii, Xsear
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint64 NODE_TAG_MAGIC = 0x12ED5A12ED5B12ED;

struct Node;

struct NodeHeader {
    uint64 magicTag<hidden=true>;
    uint nodeType;
    uint32 len;
};


struct vec3 {
    float x;
    float y;
    float z;
};


// Geometry Node Data
//============================

struct GeoVertData {
    uint vertCount;
    vec3 verts[vertCount] <read=Vec3Display>;
};

struct indiceType1 {
    ushort a;
    ushort b;  
    ushort c;
};

struct indiceType2 {
    byte a;
    byte b;
    byte c;
};

struct indiceBlock {
    uint count;
    uint indiceType;

    if (indiceType == 393218) {
        indiceType1 indices[count];
    }
    else if (indiceType == 196609) {
        indiceType2 indices[count];
    }
    
};

struct matsDataBlock {
    uint count;
    uint id; // Might be type as well?
    byte data[count];
};

struct moppDataBlock {
    float floats[4];
    uint size;
    byte data[size];

    byte unk1;
    ushort unk2;

    uint numShorts;
    ushort shorts[numShorts];
};

struct GeometryData(uint nodeSize) {
    local uint startPos = FTell();    

    uint magic;
    ushort version; // ? should be 3
    ushort revision; // ? checked if less than 5
    uint unk1; // seems like a unique id
    uint numPhysicsMatIds;
    uint physicsMatIds[numPhysicsMatIds];

    uint numVertBlocks;
    GeoVertData vertBlocks[numVertBlocks] <optimize=false>;

    uint numIndiceBlocks;
    indiceBlock indiceBlocks[numIndiceBlocks] <optimize=false>;

    uint numMatItems;
    matsDataBlock matBlocks[numMatItems] <optimize=false>;

    uint numMoppBlocks;
    moppDataBlock moppBlocks[numMoppBlocks] <optimize=false>;

    local uint endPos = FTell(); 
    local uint leftSize = nodeSize - (endPos - startPos);
    byte havokData[leftSize];
};

// Props Dode Data
//============================

struct PropsDataChunk(uint nodeSize) {
    while( FTell() < nodeSize ) {
        Node subNode;
    }
};

struct PropNodeEntry_LightData {
    byte header[64];
    uint unk1;
    float unk2[6];
    uint unk4;
};

// Mesh instances ?
//============================

struct MeshInstanceBlock {
ushort count;
    ushort unk1;
    uint unk2;
    uint unk3;

    uint unk4;
    uint unk5;

    float unkFloat[6];
    uint64 unk6; // not on 262659 node id
    uint unk7;
    uint unk8;
    byte unk9[1100]; // some mat stuff sub_19B1220

    uint unk10;
};

// Terrain Chunk 
//============================

struct TerrainChunk_type0 {
    uint unk1;
    uint unk2;
    uint unk3;
    vec3 vec; 
};

struct TerrainChunk_type3 {
    uint count;
    uint data[count];
};

struct TerrainChunk_type4(uint nodeSize) {
    uint nodeCount;
    struct T4Node {
        uint nodeIndex; // node index within a level
        uint nodeLevel; // node.mLevel <= cTerrainMaxChunkNodeLevel
        uint unk3; // flags?
        vec3 matrix[3] <read=Vec3Display>;
        float unk7;
        vec3 boundsMin <read=Vec3Display>;
        vec3 boundsMax <read=Vec3Display>;
        uint unk9; // Number of vertices?
        byte unk10[16]; // Needs to be parsed
        uint unk11; // (unk15 * 3)
        ushort unk12;

        uint unk13;
        if (unk13 != 0xffffffff) { // when node level is not 0?
            ushort unk14[unk13];
        }
    
        uint unk15; // Number of patch triangles?
    
        byte haveMaterials;
        if (haveMaterials > 0) {
            uint materials[6]; // refmap?
        }
        
        uint unk18_size; // client will attempt to allocate this number of bytes
    };
    
    T4Node nodes[nodeCount] <optimize=false>;
    
    // :thinking:
    //local int i;
    //local uint dataSize;
    //struct nodeData(uint dataSize) {
    //    byte data[dataSize];
    //};
    //for ( i = 0; i < nodeCount; i++) {
    //    dataSize = nodes[i].unk18_size;
    //    nodeData dat(dataSize);
    //}
};

struct TerrainChunk(uint nodeSize) {
    while( FTell() < nodeSize ) {
        NodeHeader header;
        if (header.nodeType == 4) {
            TerrainChunk_type4 data(header.len);
            byte dataLeft[header.len - sizeof(data)];
        }
        else if (header.nodeType == 3) {
            TerrainChunk_type3 data;
        }
        else if (header.nodeType == 0) {
            TerrainChunk_type0 data;
        }
        else {
            byte data[header.len];
        }
    }
};

// 
//============================


struct UnkNode1Data {
    ushort unk1; // a count
    ushort unk2;
    ushort unk3;
    ushort unk4;
    ushort unk5;
    ushort unk6;

    struct UnkNode1SubData {
        uint idx;
        byte unk[8];
    };
    UnkNode1SubData unk1Data[unk1];
};

//============================

struct Node {
    uint64 magicTag<hidden=true>;
    enum <uint32> {
            Terrain          = 262400, // parent, children are "terrain chunk layer"
                Terrain_T0              = 0,
                TerrainChunk_Materials  = 1, // parent, children are "terrain chunk material layer"
                    TerrainChunk_MaterialLayer  = 5,
                Terrain_T2              = 2, // might be blend weight layer
                Terrain_T3              = 3, // list of terrain materials to load
                Terrain_T4              = 4,
            Geometry         = 262401,
            SubZoneGrid      = 262402,
            Geometry3        = 262403,
            PropEncNameReg2  = 262404, // seen in shared lod data,  "chunk prop encounter name registry"
            Geometry2        = 262405,
            PropsNode        = 262656, // parent, children are "prop type layer"
                PropType_Doodad           = 327680, // same id as zone files, probably same parsing then
                PropType_EnvironmentData  = 327681, // environment prop data, these ids are also in the zone files
                    DefaultEnvironmentLayer_0034  = 34,
                    DefaultEnvironmentLayer_0203  = 203,
                    DefaultEnvironmentLayer_0304  = 304, 
                    DefaultEnvironmentLayer_0401  = 401, 
                    DefaultEnvironmentLayer_0501  = 501, 
                    DefaultEnvironmentLayer_0601  = 601, 
                    DefaultEnvironmentLayer_0700  = 700, 
                    DefaultEnvironmentLayer_0900  = 900, 
                    DefaultEnvironmentLayer_0800  = 800, 
                    DefaultEnvironmentLayer_1000  = 1000,
                    DefaultEnvironmentLayer_1200  = 1200,
                    DefaultEnvironmentLayer_1300  = 1300,
                    DefaultEnvironmentLayer_1400  = 1400,
                PropType_ProbeData        = 327686,
                PropType_DecalInstances1  = 327688,
                PropType_ParticleData     = 327693, // Bit unsure, seems like it should have children
                PropType_LightData        = 327697,
                PropType_AudioVolume      = 327700,
                PropType_Monster          = 327703,
                PropType_DecalInstances2  = 327704,
            UnkNode1         = 262659, // similiar to MeshInstance
            PropEncNameReg   = 262660, // "chunk prop encounter name registry"
            VegationChunk    = 262661,
            OverlayChunk     = 262662,
            SectorsChunk     = 262663,
                SectorsEntry    = 327699,
            WaterObjectChunk = 262664,
            VegationChunk2   = 262665,
            MeshInstance     = 262672
            
        } nodeType;
        uint32 len;

    local uint64 startPos = FTell();

    if (nodeType == Geometry || nodeType == Geometry2 || nodeType == Geometry3) {
        GeometryData data(len);
        byte geoLeftData[len - sizeof(data)];
    }
    else if (nodeType == Terrain) {
        TerrainChunk data(len);
        byte leftData[len - sizeof(data)];
    }
    else if (nodeType == PropsNode) {
        PropsDataChunk data(startPos + len);
        byte leftData[len - sizeof(data)];
    }
    else if (nodeType == PropType_LightData) {
        PropNodeEntry_LightData entry;
        byte leftData[len - sizeof(entry)];
    }
    else if (nodeType == MeshInstance) {
        MeshInstanceBlock data;
        byte leftData[len - sizeof(data)];
    }
    else if (nodeType == UnkNode1) {
        UnkNode1Data data;
        byte leftData[len - sizeof(data)];
    }
    else {
        byte data[len];
    }
};

while( FTell() < FileSize() ) {
    Node node ;
}

// display formating
string Vec3Display(vec3 &vec)
{
    string s;   
    SPrintf( s, "%f, %f, %f", vec.x, vec.y, vec.z );
    return s;
}
