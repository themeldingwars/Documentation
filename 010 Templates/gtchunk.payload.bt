//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: gtchunk compressed node
//   Authors: Arkii, Xsear
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

local uint64 NODE_TAG_MAGIC = 0x12ED5A12ED5B12ED;

struct Node;

struct NodeHeader {
    uint64 magicTag<hidden=true>;
    uint nodeType;
    uint32 len;
};


struct vec3 {
    float x;
    float y;
    float z;
};

struct vec4 {
    float x;
    float y;
    float z;
    float w;
};

struct matrix4x4 {
    vec4 a<read=Vec4Display, optimize=false>;
    vec4 b<read=Vec4Display, optimize=false>;
    vec4 c<read=Vec4Display, optimize=false>;
    vec4 d<read=Vec4Display, optimize=false>;
};

// Geometry Node Data
//============================

struct GeoVertData {
    uint vertCount;
    vec3 verts[vertCount] <read=Vec3Display>;
};

struct indiceType1 {
    ushort a;
    ushort b;  
    ushort c;
};

struct indiceType2 {
    byte a;
    byte b;
    byte c;
};

struct indiceBlock {
    uint count;
    uint indiceType;

    if (indiceType == 393218) {
        indiceType1 indices[count];
    }
    else if (indiceType == 196609) {
        indiceType2 indices[count];
    }
    
};

struct matsDataBlock {
    uint count;
    uint id; // Might be type as well?
    byte data[count];
};

struct moppDataBlock {
    float floats[4];
    uint size;
    byte data[size];

    byte unk1;
    ushort unk2;

    uint numShorts;
    ushort shorts[numShorts];
};

struct GeometryData(uint nodeSize) {
    local uint startPos = FTell();    

    uint magic;
    ushort version; // ? should be 3
    ushort revision; // ? checked if less than 5
    uint unk1; // seems like a unique id
    uint numPhysicsMatIds;
    uint physicsMatIds[numPhysicsMatIds];

    struct GeoBlockStorage {
        uint numVertBlocks;
        GeoVertData vertBlocks[numVertBlocks] <optimize=false>;

        uint numIndiceBlocks;
        indiceBlock indiceBlocks[numIndiceBlocks] <optimize=false>;

        uint numMatItems;
        matsDataBlock matBlocks[numMatItems] <optimize=false>;

        uint numMoppBlocks;
        moppDataBlock moppBlocks[numMoppBlocks] <optimize=false>;
    } store <read=GeoStoreDisplay>;

    struct HavokData(uint endPos) {
        uint64 havocBeginMagicTag;
        
        // type section
        local uint havocBeginPos = FTell();
        local string havocEndClassesTag = "
@";
        local uint havocClassesEndTagPos = FindFirst(havocEndClassesTag, true, false, 0, 0.0, 1, havocBeginPos);
        byte havokClasses[havocClassesEndTagPos-havocBeginPos];
        uint havokClassesEndTag;
        // --

        // data section 
        // try to parse some data based on common patterns
        local uint havokNext04Pos = FindFirst("", true, false, 0, 0.0, 1, FTell()+1);
        byte havokUnk1[havokNext04Pos-FTell()+1];
    
        vec4 havokVector1<read=Vec4Display>; // hkpListShape aabbHalfExtents?
        vec4 havokVector2<read=Vec4Display>; // hkpListShape aabbCenter?
    
        local uint havokUnk2EndPos = FindFirst("", true, false, 0, 0.0, 1, FTell());

        if ( havokUnk2EndPos < havokEndPos ) {
 
            byte havokUnk2[havokUnk2EndPos - FTell()+3]; // the bytes before the last three are interesting, are they 2 bytes per combined shape?
        
            matrix4x4 havokMatrix1<optimize=false>; // ?
            vec4 havokVector3<read=Vec4Display>; // often similiar to the previous two vectors
            vec4 havokVector4<read=Vec4Display>; // but not always
    
            if (store.numVertBlocks > 0) { // Protect against errors when guess mockering
                byte havokUnk_MaybeImportant[ FindFirst("", true, false, 0, 0.0, 1, FTell()) - FTell() ];
                byte havokUnk_ShouldBe8_1;
                byte data_group1[ FindFirst("", true, false, 0, 0.0, 1, FTell()+1) - FTell()];
                byte havokUnk_ShouldBe8_2;
                byte data_group2[ FindFirst("", true, false, 0, 0.0, 1, FTell()+1) - FTell()];
                byte havokUnk_ShouldBe8_3;    
                
                // wish we could search for sequence: 0x06 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00
                // searching for sequence 2 6 0 which is not correct for some cases
                local string havokUnk3SearchSequence1 = "
